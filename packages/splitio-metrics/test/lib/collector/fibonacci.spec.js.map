{"version":3,"sources":["../../es6/collector/fibonacci.spec.js"],"names":[],"mappings":"AAAA;;AAEA,IAAI,OAAO,QAAQ,MAAR,CAAP;AACJ,IAAI,mBAAmB,QAAQ,kCAAR,CAAnB;;AAEJ,KAAK,oDAAL,EAA2D,kBAAU;AACnE,MAAI,KAAK,kBAAL,CAD+D;;AAGnE,KAAG,KAAH,CAAS,CAAT,EAHmE;AAInE,KAAG,KAAH,CAAS,IAAT,EAJmE;AAKnE,KAAG,KAAH,CAAS,IAAT,EALmE;;AAOnE,SAAO,IAAP,CAAY,GAAG,QAAH,GAAc,CAAd,MAAqB,CAArB,EAAwB,6BAApC,EAPmE;;AASnE,KAAG,KAAH,CAAS,IAAT,EATmE;AAUnE,SAAO,IAAP,CAAY,GAAG,QAAH,GAAc,CAAd,MAAqB,CAArB,EAAwB,6BAApC,EAVmE;;AAYnE,KAAG,KAAH,CAAS,IAAT,EAZmE;AAanE,SAAO,IAAP,CAAY,GAAG,QAAH,GAAc,CAAd,MAAqB,CAArB,EAAwB,6BAApC,EAbmE;;AAenE,KAAG,KAAH,CAAS,MAAT,EAfmE;AAgBnE,SAAO,IAAP,CAAY,GAAG,QAAH,GAAc,EAAd,MAAsB,CAAtB,EAAyB,8BAArC,EAhBmE;;AAkBnE,KAAG,KAAH,CAAS,MAAT,EAlBmE;AAmBnE,SAAO,IAAP,CAAY,GAAG,QAAH,GAAc,EAAd,MAAsB,CAAtB,EAAyB,8BAArC,EAnBmE;;AAqBnE,KAAG,KAAH,CAAS,OAAT,EArBmE;AAsBnE,SAAO,IAAP,CAAY,GAAG,QAAH,GAAc,EAAd,MAAsB,CAAtB,EAAyB,8BAArC,EAtBmE;;AAwBnE,SAAO,GAAP,GAxBmE;CAAV,CAA3D;;AA2BA,KAAK,oDAAL,EAA2D,kBAAU;AACnE,MAAI,KAAK,kBAAL,CAD+D;;AAGnE,KAAG,KAAH,CAAS,CAAT,EAHmE;AAInE,KAAG,KAAH,CAAS,IAAT,EAJmE;AAKnE,KAAG,KAAH,CAAS,IAAT,EALmE;AAMnE,KAAG,KAAH,CAAS,IAAT,EANmE;AAOnE,KAAG,KAAH,CAAS,IAAT,EAPmE;AAQnE,KAAG,KAAH,CAAS,MAAT,EARmE;AASnE,KAAG,KAAH,CAAS,MAAT,EATmE;AAUnE,KAAG,KAAH,CAAS,OAAT,EAVmE;;AAYnE,SAAO,IAAP,CACE,GAAG,KAAH,GAAW,QAAX,GAAsB,MAAtB,CAA6B,UAAC,GAAD,EAAM,CAAN;WAAY,OAAO,CAAP;GAAZ,EAAsB,CAAnD,MAA0D,CAA1D,EACA,wCAFF,EAZmE;;AAiBnE,SAAO,GAAP,GAjBmE;CAAV,CAA3D;;AAoBA,KAAK,2DAAL,EAAkE,kBAAU;AAC1E,MAAI,IAAI,kBAAJ,CADsE;AAE1E,MAAI,SAAS,KAAK,SAAL,CAAe,CAAf,CAAT,CAFsE;AAG1E,MAAI,SAAS,KAAK,SAAL,CAAe,EAAE,QAAF,EAAf,CAAT,CAHsE;;AAK1E,SAAO,IAAP,CAAY,WAAW,MAAX,EAAmB,0DAA/B,EAL0E;AAM1E,SAAO,GAAP,GAN0E;CAAV,CAAlE","file":"fibonacci.spec.js","sourcesContent":["'use strict';\n\nlet tape = require('tape');\nlet collectorFactory = require('../../../lib/collector/fibonacci');\n\ntape('FIBONACCI COLLECTOR / should count based on ranges', assert => {\n  let c1 = collectorFactory();\n\n  c1.track(1);\n  c1.track(1000);\n  c1.track(1001);\n\n  assert.true(c1.counters()[0] === 3, 'the bucket #0 should have 3');\n\n  c1.track(1500);\n  assert.true(c1.counters()[1] === 1, 'the bucket #1 should have 1');\n\n  c1.track(3456);\n  assert.true(c1.counters()[3] === 1, 'the bucket #3 should have 1');\n\n  c1.track(985251);\n  assert.true(c1.counters()[16] === 1, 'the bucket #17 should have 1');\n\n  c1.track(985271);\n  assert.true(c1.counters()[17] === 1, 'the bucket #18 should have 1');\n\n  c1.track(7481830);\n  assert.true(c1.counters()[22] === 1, 'the bucket #22 should have 1');\n\n  assert.end();\n});\n\ntape('FIBONACCI COLLECTOR / should count based on ranges', assert => {\n  let c1 = collectorFactory();\n\n  c1.track(1);\n  c1.track(1000);\n  c1.track(1001);\n  c1.track(1500);\n  c1.track(3456);\n  c1.track(985251);\n  c1.track(985271);\n  c1.track(7481830);\n\n  assert.true(\n    c1.clear().counters().reduce((sum, c) => sum += c, 0) === 0,\n    'after call clear, counters should be 0'\n  );\n\n  assert.end();\n});\n\ntape('FIBONACCI COLLECTOR / should support custom toJSON method', assert => {\n  let c = collectorFactory();\n  let hooked = JSON.stringify(c);\n  let manual = JSON.stringify(c.counters());\n\n  assert.true(hooked === manual, 'toJSON should expose the counters as an array of numbers');\n  assert.end();\n});\n"]}