{"version":3,"sources":["../../es6/parser/condition.js"],"names":[],"mappings":"WAAY;;AAEZ,IAAI,wBAAwB,QAAQ,4BAAR,CAAxB;AACJ,IAAI,sBAAsB,QAAQ,0BAAR,CAAtB;;AAEJ,IAAI,eAAe,QAAQ,mBAAR,EAA6B,IAA7B;AACnB,IAAI,iBAAiB,QAAQ,aAAR,CAAjB;;AAEJ,IAAI,mBAAmB,QAAQ,cAAR,CAAnB;;AAEJ,IAAI,cAAc,QAAQ,kBAAR,CAAd;;;;;;;;;AASJ,SAAS,KAAT,CAAe,UAAf,EAA2B;AACzB,MAAI,aAAa,EAAb,CADqB;AAEzB,MAAI,WAAW,IAAI,GAAJ,EAAX,CAFqB;AAGzB,MAAI,YAAY,IAAZ,CAHqB;;;;;;;AAKzB,yBAAsB,oCAAtB,oGAAkC;UAAzB,wBAAyB;;AAChC,UAAI,kBAAkB,sBAAsB,UAAU,YAAV,CAAxC,CAD4B;AAEhC,UAAI,mBAAmB,eAAe,eAAf,CAAnB,CAF4B;AAGhC,UAAI,aAAa,oBAAoB,UAAU,UAAV,CAAjC;;;AAH4B,UAM5B,gBAAgB,IAAhB,KAAyB,aAAa,OAAb,EAAsB;AACjD,iBAAS,GAAT,CAAa,gBAAgB,KAAhB,CAAb,CADiD;OAAnD;;AAIA,iBAAW,IAAX,CAAgB,iBAAiB,gBAAjB,EAAmC,UAAnC,CAAhB,EAVgC;KAAlC;;;;;;;;;;;;;;;;GALyB;;AAmBzB,cAAY,YAAY,UAAZ,CAAZ,CAnByB;;AAqBzB,SAAO;AACL,sBADK;AAEL,wBAFK;GAAP,CArByB;CAA3B;;AA2BA,OAAO,OAAP,GAAiB,KAAjB","file":"condition.js","sourcesContent":["/* @flow */ 'use strict';\n\nlet matcherGroupTransform = require('../transforms/matcherGroup');\nlet partitionsTransform = require('../transforms/partitions');\n\nlet matcherTypes = require('../matchers/types').enum;\nlet matcherFactory = require('../matchers');\n\nlet evaluatorFactory = require('../evaluator');\n\nlet andCombiner = require('../combiners/and');\n\n/**\n * Collect segmentNames and create the evaluator function given a list of\n * conditions.\n *\n * @params {Iterable} conditions Collection of conditions present in a given Split.\n * @return {Object} .segments and .evaluator based on the given set of conditions.\n */\nfunction parse(conditions) {\n  let predicates = [];\n  let segments = new Set();\n  let evaluator = null;\n\n  for (let condition of conditions) {\n    let matcherMetadata = matcherGroupTransform(condition.matcherGroup);\n    let matcherEvaluator = matcherFactory(matcherMetadata);\n    let partitions = partitionsTransform(condition.partitions);\n\n    // Incrementally collect segmentNames\n    if (matcherMetadata.type === matcherTypes.SEGMENT) {\n      segments.add(matcherMetadata.value);\n    }\n\n    predicates.push(evaluatorFactory(matcherEvaluator, partitions));\n  }\n\n  // Instanciate evaluator given the set of conditions\n  evaluator = andCombiner(predicates);\n\n  return {\n    segments,\n    evaluator\n  };\n}\n\nmodule.exports = parse;\n"]}