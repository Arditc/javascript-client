{"version":3,"sources":["../../es6/parser/condition.js"],"names":[],"mappings":"WAAY,YAAY,CAAC;;AAEzB,IAAI,qBAAqB,GAAG,OAAO,CAAC,4BAA4B,CAAC,CAAC;AAClE,IAAI,mBAAmB,GAAG,OAAO,CAAC,0BAA0B,CAAC,CAAC;;AAE9D,IAAI,YAAY,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC;AACrD,IAAI,cAAc,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;;AAE5C,IAAI,gBAAgB,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;;AAE/C,IAAI,WAAW,GAAG,OAAO,CAAC,kBAAkB,CAAC;;;;;;;;;AAAC,AAS9C,SAAS,KAAK,CAAC,UAAU,EAAE;AACzB,MAAI,UAAU,GAAG,EAAE,CAAC;AACpB,MAAI,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;AACzB,MAAI,SAAS,GAAG,IAAI,CAAC;;;;;;;AAErB,yBAAsB,UAAU,8HAAE;UAAzB,SAAS;;AAChB,UAAI,eAAe,GAAG,qBAAqB,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;AACpE,UAAI,gBAAgB,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;AACvD,UAAI,UAAU,GAAG,mBAAmB,CAAC,SAAS,CAAC,UAAU,CAAC;;;AAAC,AAG3D,UAAI,eAAe,CAAC,IAAI,KAAK,YAAY,CAAC,OAAO,EAAE;AACjD,gBAAQ,CAAC,GAAG,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;OACrC;;AAED,gBAAU,CAAC,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC,CAAC;KACjE;;;AAAA;;;;;;;;;;;;;;;AAGD,WAAS,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;;AAEpC,SAAO;AACL,YAAQ,EAAR,QAAQ;AACR,aAAS,EAAT,SAAS;GACV,CAAC;CACH;;AAED,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC","file":"condition.js","sourcesContent":["/* @flow */ 'use strict';\n\nlet matcherGroupTransform = require('../transforms/matcherGroup');\nlet partitionsTransform = require('../transforms/partitions');\n\nlet matcherTypes = require('../matchers/types').enum;\nlet matcherFactory = require('../matchers');\n\nlet evaluatorFactory = require('../evaluator');\n\nlet andCombiner = require('../combiners/and');\n\n/**\n * Collect segmentNames and create the evaluator function given a list of\n * conditions.\n *\n * @params {Iterable} conditions Collection of conditions present in a given Split.\n * @return {Object} .segments and .evaluator based on the given set of conditions.\n */\nfunction parse(conditions) {\n  let predicates = [];\n  let segments = new Set();\n  let evaluator = null;\n\n  for (let condition of conditions) {\n    let matcherMetadata = matcherGroupTransform(condition.matcherGroup);\n    let matcherEvaluator = matcherFactory(matcherMetadata);\n    let partitions = partitionsTransform(condition.partitions);\n\n    // Incrementally collect segmentNames\n    if (matcherMetadata.type === matcherTypes.SEGMENT) {\n      segments.add(matcherMetadata.value);\n    }\n\n    predicates.push(evaluatorFactory(matcherEvaluator, partitions));\n  }\n\n  // Instanciate evaluator given the set of conditions\n  evaluator = andCombiner(predicates);\n\n  return {\n    segments,\n    evaluator\n  };\n}\n\nmodule.exports = parse;\n"]}