{"version":3,"sources":["../../es6/parser/condition.js"],"names":[],"mappings":"WAAY;;AAEZ,IAAI,wBAAwB,QAAQ,4BAAR,CAAxB;AACJ,IAAI,mBAAmB,QAAQ,eAAR,EAAyB,KAAzB;;AAEvB,IAAI,eAAe,QAAQ,mBAAR,EAA6B,IAA7B;AACnB,IAAI,iBAAiB,QAAQ,aAAR,CAAjB;;AAEJ,IAAI,mBAAmB,QAAQ,cAAR,CAAnB;;AAEJ,IAAI,cAAc,QAAQ,kBAAR,CAAd;;;;;;;;;;;;AAYJ,SAAS,KAAT,CAAe,kCAAf,wBAA0E;AACxE,MAAI,aAAa,EAAb,CADoE;AAExE,MAAI,WAAW,IAAI,GAAJ,EAAX,CAFoE;AAGxE,MAAI,YAAY,IAAZ,CAHoE;;;;;;;AAKxE,yBAAsB,oCAAtB,oGAAkC;UAAzB,wBAAyB;;AAChC,UAAI,kBAAkB,sBAAsB,UAAU,YAAV,CAAxC,CAD4B;AAEhC,UAAI,mBAAmB,eAAe,eAAf,CAAnB,CAF4B;AAGhC,UAAI,aAAa,iBAAiB,UAAU,UAAV,CAA9B;;;AAH4B,UAM5B,gBAAgB,IAAhB,KAAyB,aAAa,OAAb,EAAsB;AACjD,iBAAS,GAAT,CAAa,gBAAgB,KAAhB,CAAb,CADiD;OAAnD;;AAIA,iBAAW,IAAX,CAAgB,iBAAiB,gBAAjB,EAAmC,UAAnC,CAAhB,EAVgC;KAAlC;;;;;;;;;;;;;;;;GALwE;;AAmBxE,cAAY,YAAY,UAAZ,CAAZ,CAnBwE;;AAqBxE,SAAO;AACL,sBADK;AAEL,wBAFK;GAAP,CArBwE;CAA1E;;AA2BA,OAAO,OAAP,GAAiB,KAAjB","file":"condition.js","sourcesContent":["/* @flow */ 'use strict';\n\nlet matcherGroupTransform = require('../transforms/matcherGroup');\nlet treatmentsParser = require('../treatments').parse;\n\nlet matcherTypes = require('../matchers/types').enum;\nlet matcherFactory = require('../matchers');\n\nlet evaluatorFactory = require('../evaluator');\n\nlet andCombiner = require('../combiners/and');\n\n/*::\n  type ParserOutputDTO = {\n    segments: Set,\n    evaluator: (key: string, seed: number) => boolean\n  }\n*/\n\n// Collect segments and create the evaluator function given a list of\n// conditions. This code is the base used by the class `Split` for\n// instanciation.\nfunction parse(conditions /*: Iterable<Object> */) /*: ParserOutputDTO */ {\n  let predicates = [];\n  let segments = new Set();\n  let evaluator = null;\n\n  for (let condition of conditions) {\n    let matcherMetadata = matcherGroupTransform(condition.matcherGroup);\n    let matcherEvaluator = matcherFactory(matcherMetadata);\n    let treatments = treatmentsParser(condition.partitions);\n\n    // Incrementally collect segmentNames\n    if (matcherMetadata.type === matcherTypes.SEGMENT) {\n      segments.add(matcherMetadata.value);\n    }\n\n    predicates.push(evaluatorFactory(matcherEvaluator, treatments));\n  }\n\n  // Instanciate evaluator given the set of conditions\n  evaluator = andCombiner(predicates);\n\n  return {\n    segments,\n    evaluator\n  };\n}\n\nmodule.exports = parse;\n"]}