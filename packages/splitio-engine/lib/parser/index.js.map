{"version":3,"sources":["../../es6/parser/index.js"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAM,wBAAwB,QAAQ,4BAAR,CAAxB;AACN,IAAM,mBAAmB,QAAQ,eAAR,EAAyB,KAAzB;;AAEzB,IAAM,eAAe,QAAQ,mBAAR,EAA6B,IAA7B;AACrB,IAAM,iBAAiB,QAAQ,aAAR,CAAjB;;AAEN,IAAM,mBAAmB,QAAQ,cAAR,CAAnB;;AAEN,IAAM,cAAc,QAAQ,kBAAR,CAAd;;;;;;;;;;;;AAYN,SAAS,KAAT,CAAe,kCAAf,EAAmD,sBAAnD,wBAAkG;AAChG,MAAI,aAAa,EAAb,CAD4F;AAEhG,MAAI,WAAW,mBAAX,CAF4F;AAGhG,MAAI,YAAY,IAAZ,CAH4F;;;;;;;AAKhG,oDAAsB,kBAAtB,oGAAkC;UAAzB,wBAAyB;;AAChC,UAAI,kBAAkB,sBAAsB,UAAU,YAAV,CAAxC,CAD4B;AAEhC,UAAI,mBAAmB,eAAe,eAAf,EAAgC,OAAhC,CAAnB,CAF4B;AAGhC,UAAI,aAAa,iBAAiB,UAAU,UAAV,CAA9B;;;AAH4B,UAM5B,gBAAgB,IAAhB,KAAyB,aAAa,OAAb,EAAsB;AACjD,iBAAS,GAAT,CAAa,gBAAgB,KAAhB,CAAb,CADiD;OAAnD;;AAIA,iBAAW,IAAX,CAAgB,iBAAiB,gBAAjB,EAAmC,UAAnC,CAAhB,EAVgC;KAAlC;;;;;;;;;;;;;;;;GALgG;;AAmBhG,cAAY,YAAY,UAAZ,CAAZ,CAnBgG;;AAqBhG,SAAO;AACL,sBADK;AAEL,wBAFK;GAAP,CArBgG;CAAlG;;AA2BA,OAAO,OAAP,GAAiB,KAAjB","file":"index.js","sourcesContent":["const matcherGroupTransform = require('../transforms/matcherGroup');\nconst treatmentsParser = require('../treatments').parse;\n\nconst matcherTypes = require('../matchers/types').enum;\nconst matcherFactory = require('../matchers');\n\nconst evaluatorFactory = require('../evaluator');\n\nconst andCombiner = require('../combiners/and');\n\n/*::\n  type ParserOutputDTO = {\n    segments: Set,\n    evaluator: (key: string, seed: number) => boolean\n  }\n*/\n\n// Collect segments and create the evaluator function given a list of\n// conditions. This code is the base used by the class `Split` for\n// instanciation.\nfunction parse(conditions /*: Iterable<Object> */, storage /*: Storage */) /*: ParserOutputDTO */ {\n  let predicates = [];\n  let segments = new Set();\n  let evaluator = null;\n\n  for (let condition of conditions) {\n    let matcherMetadata = matcherGroupTransform(condition.matcherGroup);\n    let matcherEvaluator = matcherFactory(matcherMetadata, storage);\n    let treatments = treatmentsParser(condition.partitions);\n\n    // Incrementally collect segmentNames\n    if (matcherMetadata.type === matcherTypes.SEGMENT) {\n      segments.add(matcherMetadata.value);\n    }\n\n    predicates.push(evaluatorFactory(matcherEvaluator, treatments));\n  }\n\n  // Instanciate evaluator given the set of conditions\n  evaluator = andCombiner(predicates);\n\n  return {\n    segments,\n    evaluator\n  };\n}\n\nmodule.exports = parse;\n"]}