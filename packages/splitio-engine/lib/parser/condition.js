/* @flow */'use strict';

var matcherGroupTransform = require('../transforms/matcherGroup');
var treatmentsParser = require('../treatments').parse;

var matcherTypes = require('../matchers/types').enum;
var matcherFactory = require('../matchers');

var evaluatorFactory = require('../evaluator');

var andCombiner = require('../combiners/and');

/**
 * Collect segmentNames and create the evaluator function given a list of
 * conditions.
 *
 * @params {Iterable} conditions Collection of conditions present in a given Split.
 * @return {Object} .segments and .evaluator based on the given set of conditions.
 */
function parse(conditions) {
  var predicates = [];
  var segments = new Set();
  var evaluator = null;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = conditions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var condition = _step.value;

      var matcherMetadata = matcherGroupTransform(condition.matcherGroup);
      var matcherEvaluator = matcherFactory(matcherMetadata);
      var treatments = treatmentsParser(condition.partitions);

      // Incrementally collect segmentNames
      if (matcherMetadata.type === matcherTypes.SEGMENT) {
        segments.add(matcherMetadata.value);
      }

      predicates.push(evaluatorFactory(matcherEvaluator, treatments));
    }

    // Instanciate evaluator given the set of conditions
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  evaluator = andCombiner(predicates);

  return {
    segments: segments,
    evaluator: evaluator
  };
}

module.exports = parse;
//# sourceMappingURL=condition.js.map