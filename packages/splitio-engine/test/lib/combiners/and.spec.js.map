{"version":3,"sources":["../../es6/combiners/and.spec.js"],"names":[],"mappings":"AAAA;;AAEA,IAAI,OAAO,QAAQ,MAAR,CAAP;AACJ,IAAI,qBAAqB,QAAQ,4BAAR,CAArB;;AAEJ,KAAK,cAAL,EAAqB,kBAAU;AAC7B,MAAI,WAAW,QAAX,CADyB;AAE7B,MAAI,YAAY,IAAZ,CAFyB;AAG7B,MAAI,mBAAmB,IAAnB,CAHyB;;AAK7B,WAAS,SAAT,CAAmB,GAAnB,EAAwB,IAAxB,EAA8B;AAC5B,WAAO,IAAP,CAAY,QAAQ,QAAR,EAAkB,sBAA9B,EAD4B;AAE5B,WAAO,IAAP,CAAY,SAAS,SAAT,EAAoB,uBAAhC,EAF4B;;AAI5B,WAAO,gBAAP,CAJ4B;GAA9B;;AAOA,MAAI,aAAa,CAAC,SAAD,CAAb,CAZyB;AAa7B,MAAI,uBAAuB,mBAAmB,UAAnB,CAAvB,CAbyB;;AAe7B,SAAO,IAAP,CACE,qBAAqB,QAArB,EAA+B,SAA/B,MAA8C,gBAA9C,+BAC2B,gBAF7B,EAf6B;AAmB7B,SAAO,GAAP,GAnB6B;CAAV,CAArB;;AAsBA,KAAK,oEAAL,EAA2E,kBAAU;AACnF,MAAI,SAAS,CAAT,CAD+E;AAEnF,MAAI,aAAa,CACf,SAAS,KAAT,GAAiB;AACf,aADe;AAEf,WAAO,SAAP,CAFe;GAAjB,EAIA,SAAS,OAAT,GAAmB;AACjB,aADiB;AAEjB,WAAO,SAAP,CAFiB;GAAnB,EAIA,SAAS,UAAT,GAAsB;AACpB,aADoB;AAEpB,WAAO,YAAP,CAFoB;GAAtB,CATE,CAF+E;;AAiBnF,MAAI,uBAAuB,mBAAmB,UAAnB,CAAvB,CAjB+E;;AAmBnF,SAAO,IAAP,CAAY,2BAA2B,SAA3B,EAAsC,4EAAlD,EAnBmF;AAoBnF,SAAO,IAAP,CAAY,WAAW,CAAX,EAAc,iDAA1B,EApBmF;AAqBnF,SAAO,GAAP,GArBmF;CAAV,CAA3E","file":"and.spec.js","sourcesContent":["'use strict';\n\nlet tape = require('tape');\nlet andCombinerFactory = require('../../../lib/combiners/and');\n\ntape('AND combiner', assert => {\n  let inputKey = 'sample';\n  let inputSeed = 1234;\n  let evaluationResult = true;\n\n  function evaluator(key, seed) {\n    assert.true(key === inputKey, 'key should be equals');\n    assert.true(seed === inputSeed, 'seed should be equals');\n\n    return evaluationResult;\n  }\n\n  let predicates = [evaluator];\n  let andCombinerEvaluator = andCombinerFactory(predicates);\n\n  assert.true(\n    andCombinerEvaluator(inputKey, inputSeed) === evaluationResult,\n    `evaluator should return ${evaluationResult}`\n  );\n  assert.end();\n});\n\ntape('AND combiner - stop evaluating when one matcher return a treatment', assert => {\n  let called = 0;\n  let predicates = [\n    function undef() {\n      called++;\n      return undefined;\n    },\n    function exclude() {\n      called++;\n      return 'exclude';\n    },\n    function alwaysTrue() {\n      called++;\n      return 'alwaysTrue';\n    }\n  ];\n\n  let andCombinerEvaluator = andCombinerFactory(predicates);\n\n  assert.true(andCombinerEvaluator() === 'exclude', 'The combiner should STOP at the first predicates which returns a treatment');\n  assert.true(called === 2, 'Just 2 predicates should be called in this test');\n  assert.end();\n});\n"]}