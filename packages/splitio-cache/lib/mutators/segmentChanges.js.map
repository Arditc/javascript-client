{"version":3,"sources":["../../es6/mutators/segmentChanges.js"],"names":[],"mappings":"WAAY;;;;;;;;;;;AAWZ,IAAI,MAAM,QAAQ,WAAR,EAAqB,GAArB;;;;;;;;;AASV,SAAS,uBAAT,gCAAkF;MAAhD,iBAAgD;MAA1C,mBAA0C;MAAnC,uBAAmC;;AAEhF,SAAO,SAAS,gBAAT,CAA0B,cAA1B,EAA0C,cAA1C,EAA0D;AAC/D,mBACE,IADF,EAEE,CAAC,eAAe,IAAf,KAAwB,IAAI,GAAJ,EAAxB,CAAD,CAAoC,KAApC,CAA0C,KAA1C,EAAiD,QAAjD,CAA0D,OAA1D,CAFF,EAD+D;GAA1D,CAFyE;CAAlF;;AAWA,OAAO,OAAP,GAAiB,uBAAjB","file":"segmentChanges.js","sourcesContent":["/* @flow */ 'use strict';\n\n/**\n@TODO\n\n1- Mutations should be applied on the storage and I'm not 100% sure about\n   having 2 arguments instead of just provide the data structure as is.\n2- Data initialization is part of the implementation, here I have another\n   point to think about.\n**/\n\nlet Set = require('Immutable').Set;\n\n/*::\n  type SegmentChangesDTO {\n    name: string,\n    added: Array<string>,\n    removed: Array<string>\n  }\n*/\nfunction segmentMutationsFactory({name, added, removed} /*: SegmentChangesDTO */) {\n\n  return function segmentMutations(storageAccesor, storageMutator) {\n    storageMutator(\n      name,\n      (storageAccesor(name) || new Set()).union(added).subtract(removed)\n    );\n  };\n\n}\n\nmodule.exports = segmentMutationsFactory;\n"]}