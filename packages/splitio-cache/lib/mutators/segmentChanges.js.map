{"version":3,"sources":["../../es6/mutators/segmentChanges.js"],"names":[],"mappings":"WAAY,YAAY;;;;;;;;;;;AAAC,AAWzB,IAAI,GAAG,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,GAAG;;;;;;;;;AAAC,AASnC,SAAS,uBAAuB,gCAAkD;MAAhD,IAAI,QAAJ,IAAI;MAAE,KAAK,QAAL,KAAK;MAAE,OAAO,QAAP,OAAO;;AAEpD,SAAO,SAAS,gBAAgB,CAAC,cAAc,EAAE,cAAc,EAAE;AAC/D,kBAAc,CACZ,IAAI,EACJ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,IAAI,GAAG,EAAE,CAAA,CAAE,KAAK,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CACnE,CAAC;GACH,CAAC;CAEH;;AAED,MAAM,CAAC,OAAO,GAAG,uBAAuB,CAAC","file":"segmentChanges.js","sourcesContent":["/* @flow */ 'use strict';\n\n/**\n@TODO\n\n1- Mutations should be applied on the storage and I'm not 100% sure about\n   having 2 arguments instead of just provide the data structure as is.\n2- Data initialization is part of the implementation, here I have another\n   point to think about.\n**/\n\nlet Set = require('Immutable').Set;\n\n/*::\n  type SegmentChangesDTO {\n    name: string,\n    added: Array<string>,\n    removed: Array<string>\n  }\n*/\nfunction segmentMutationsFactory({name, added, removed} /*: SegmentChangesDTO */) {\n\n  return function segmentMutations(storageAccesor, storageMutator) {\n    storageMutator(\n      name,\n      (storageAccesor(name) || new Set()).union(added).subtract(removed)\n    );\n  };\n\n}\n\nmodule.exports = segmentMutationsFactory;\n"]}